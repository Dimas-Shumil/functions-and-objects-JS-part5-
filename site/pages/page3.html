<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../css/sass.css">
    <title>Функции и объекты JS</title>
</head>

<body>
    <header class="header">
        <nav class="header__nav">

            <div class="header__nav-title">
                3. . Способы объявления функций и их различия
            </div>

            <ul class="header__nav-ul">
                <li><a href="../../index.html"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="page2.html"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="#"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="page4.html"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="page5.html"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="page6.html"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="page7.html"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="page8.html"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="page9.html"><span class="header__nav-ul_link"></span></a></li>
            </ul>
        </nav>
    </header>
    <hr class="hr">
    </div>

    <div class="main">
        <div class="main__wrapper">

            <div class="main__wrapper-conteiner">

                <p>В прошлом юните мы разобрали самый популярный и часто используемый способ объявления функций в
                    JavaScript. Но есть ещё несколько вариантов:</p>
                <div class="main__wrapper-box_blue">
                    <ul>
                        <li>Объявление функции (function declaration).</li>
                        <li>Функциональное выражение (function expression).</li>
                        <li>Стрелочные функции (arrow function).</li>
                        <li>Функции-конструкторы (constructor functions).</li>
                        <li>Методы объекта.</li>
                        <li>IIFE (Immediately Invoked Function Expression).</li>
                    </ul>
                </div>
                <p>Разберём каждый подробнее.</p>

                <h2>Объявление функции (function declaration)</h2>

                <p>Этот способ вам уже хорошо знаком. На его примере мы знакомились с функциями в прошлом юните. Но в
                    качестве закрепления давайте повторим его ключевые особенности.</p>
                <p>Функцию можно объявить с помощью ключевого слова function.</p>
                <div class="main__wrapper-box_grey">
                    <p>function sum(a, b) {</p>
                    <blockquote>return a + b;</blockquote>
                    <p>}</p>
                </div>
                <p>В этом примере sum — имя функции. Функция принимает два аргумента a и b, складывает их и возвращает
                    результат.</p>

                <h2>Функциональное выражение (function expression)</h2>

                <p>Этот способ сильно похож внешне на function declaration, но отличается «под капотом».</p>
                <p>Объявление функции выглядит так.</p>

                <div class="main__wrapper-box_grey">
                    <p>let sum = function (a, b) {</p>
                    <blockquote>return a + b;</blockquote>
                    <p>};</p>
                </div>

                <p>Сразу стоит отметить, что в работе и использовании функции никаких изменений не произошло. Функция
                    также будет возвращать сумму значений, переданных в качестве аргументов.</p>
                <p>Рассмотрим отличия.</p>
                <p>Во-первых, отсутствует имя функции перед аргументами. У таких функций есть специальное название —
                    анонимные. Они довольно часто применяются в случаях, когда функция передаётся в другие функции в
                    качестве аргумента или сохраняется в переменную, как в примере выше.</p>

                <div class="main__wrapper-box_lightBlue">
                    <p>Применение функций в качестве аргументов для других функций и сохранения их в переменные мы
                        подробнее рассмотрим в юните 8.4 «Использование функций». А пока запомните сам факт их
                        существования и такого применения.</p>
                </div>

                <p>Во-вторых, перед ключевым словом function появилось выражение let sum =, которое создает переменную
                    sum и сохраняет в неё анонимную функцию.</p>
                <p>В результате мы другим путём сформировали точно такую же функцию sum, которая получается при function
                    declaration.</p>
                <p>Как вы думаете, является ли корректным код ниже?</p>
                <div class="main__wrapper-box_grey">
                    <p>let sum = function add(a, b) {</p>
                    <blockquote>return a + b;</blockquote>
                    <p>};</p>
                    <p>sum(1, 2) // ?</p>
                    <p>add(2, 3) // ?</p>
                </div>
                <p>В этом коде присутствует только одно изменение. Добавлено имя функции add, которая сохраняется в
                    переменную sum.</p>
                <p>Попробуйте вызвать функцию sum самостоятельно и посмотреть на результат. Заметили разницу? А если
                    вызвать функцию add?</p>
                <p>Надеемся, что вы поэкспериментировали с этой функцией. Теперь дадим небольшой комментарий.</p>
                <p>При вызове функции sum у нас ничего не изменится. Всё будет работать корректно, как и ожидается. Но
                    сыграло ли какую-либо роль добавление имени add для анонимной функции в прошлом? Никакого. И вот
                    почему.</p>
                <p>Не важно, какое было имя у функции до сохранения её в переменную. После выполнения выражения
                    (присвоение значения переменной sum) функция add не будет существовать в её области видимости.
                    Поэтому при вызове функции add JavaScript вернёт ошибку.</p>

                <div class="main__wrapper-box-ligtGreen">
                    <p>Подробнее про то, что такое область видимости функции мы обязательно поговорим отдельно позже — в
                        юните 8.6 «Области видимости и контекст выполнения функции».</p>
                </div>

                <p>Последним и ключевым отличием function declaration от function expression является порядок их
                    выполнения.</p>
                <ul>
                    <li><strong>Function Expression</strong> создаётся, когда выполнение программы доходит до него. И
                        только после этого может использоваться.</li>
                    <li><strong>Function Declaration</strong> может быть вызвана раньше своего объявления.</li>
                </ul>
                <p>Рассмотрим это отличие на примере.</p>

                <div class="main__wrapper-box_grey">
                    <p>sayHello(); // "Привет"</p>
                    <p> function sayHello() {</p>
                    <blockquote>console.log("Привет");</blockquote>
                    <p>}</p>
                </div>

                <p>Тут функция sayHello объявлена как function declaration и код выполнится корректно.</p>

                <div class="main__wrapper-box_grey">
                    <p>sayHello(); // TypeError: sayHello is not a function</p>
                    <p>let sayHello = function () {</p>
                    <blockquote>console.log("Привет");</blockquote>
                    <p>};</p>
                </div>

                <p>А тут функция sayHello объявлена как function expression. И код вернёт ошибку.</p>
                <p>Но почему так? Ответ кроется в способе объявления.</p>
                <p>Как упоминалось выше, функции в стиле function expression буквально сохраняются в переменную. Поэтому
                    движок JavaScript работает с такими функциями так же, как с обычными переменными, объявленными с
                    помощью let или const.</p>

                <div class="main__wrapper-box-ligtGreen">
                    <p><strong>Примечание</strong></p>
                    <p>Использование переменных до их объявления в JavaScript вызывает ошибки.</p>
                </div>

                <p>А вот функции, объявленные в стиле function declaration, интерпретируются движком JavaScript иначе.
                    Сначала происходит анализ всего кода и, если встречается объявление функции, то оно «поднимается
                    наверх» и тем самым функцию можно вызывать даже перед её объявлением.</p>
                <p>Такое поведение называется hoisting («поднятие»).</p>

                <div class="main__wrapper-box_lightBlue">
                    <p>Кстати, тема отличий function declaration от function expression очень часто встречается на
                        собеседованиях, также как и hoisting. Поэтому рекомендуем тщательно изучить её, чтобы блистать
                        на интервью как матёрый сеньор. 🤩</p>
                </div>

                <h2>Стрелочные функции (arrow function)</h2>

                <p>Стрелочная функция — тип функции в JavaScript, который обеспечивает лаконичный синтаксис для
                    написания функциональных выражений. Они были введены в ECMAScript 6 (ES6). И с тех пор стали
                    популярной особенностью языка.</p>
                <p>Синтаксис очень простой и напоминает анонимные функции.</p>

                <div class="main__wrapper-box_grey">
                    <p>(аргументы) => { тело функции }</p>
                </div>

                <p>Аргументы и тело функции представляют точно такие же сущности, как и при любом другом способе
                    объявления функций. Главное отличие в том, что ключевое слово function заменяется на символ стрелки
                    (arrow) => и располагается между аргументами и телом функции.</p>

                <div class="main__wrapper-box_grey">
                    <p>const helloStudent = (name) => {</p>
                    <blockquote>console.log(`Привет, ${name}!`);</blockquote>
                    <p>};</p>
                    <p>helloStudent("Энакин Скайуокер"); // "Привет, Энакин Скайуокер!"</p>
                </div>

                <p>В результате мы получаем функцию helloStudent, которая работает точно так же, как и другие функции,
                    объявленные другими способами.</p>
                <p>Стрелочные функции имеют ряд преимуществ перед традиционными выражениями функций:</p>

                <p>1. Лаконичный синтаксис. Это облегчает их чтение и написание, особенно для простых функций.</p>
                <p>2. Неявный возврат значений. Э2. то означает, что вам не нужно использовать ключевое слово return.
                </p>



                <div class="main__wrapper-box_grey">
                    <p>const double = (num) => num * 2;</p>
                </div>
                <p>В результате выполнения функции у нас выполнится выражение (num * 2) и результат будет автоматически
                    возвращён из функции. Поэтому нет необходимости использовать return.</p>
                <p>3. Стрелочные функции наследуют значение this из родительского контекста. Об этой особенности
                    поговорим в юните «8.6 Область видимости и контекст выполнения функции». В нём подробно разберём
                    контекст и области видимости.</p>
                <p>Стоит также отметить, что стрелочные функции используются также часто (если не чаще), как function
                    declaration.</p>

                <h2>Функции-конструкторы (constructor functions)</h2>

                <p>Функции-конструкторы используются для создания новых объектов с помощью ключевого слова new.</p>

                <div class="main__wrapper-box_grey">
                    <p>function User(name, age) {</p>
                    <blockquote>this.name = name;</blockquote>
                    <blockquote>this.age = age;</blockquote>
                    <p>}</p>
                    <p>let person = new User("C3P0", 90);</p>
                </div>

                <p>В этом примере User — функция-конструктор, которая принимает два аргумента name и age. При вызове с
                    помощью new, она создаёт новый объект и присваивает ему свойства name и age.</p>
                <p>Такой способ теперь редко используется. С обновлением ES6 появилось новое ключевое слово class. Его
                    используют для описания классов в новом стиле. А функции-конструкторы вы можете встретить в каких-то
                    устаревших материалах или коде. Поэтому не рекомендуем создавать так новые объекты.</p>

                <h2>Методы объекта</h2>

                <p>Функции можно также объявлять как методы объекта.</p>

                <div class="main__wrapper-box_grey">
                    <p>let calculator = {</p>
                    <blockquote>sum: function (a, b) {</blockquote>
                    <blockquote>
                        <blockquote>return a + b;</blockquote>
                    </blockquote>
                    <blockquote>};</blockquote>
                    <blockquote>}</blockquote>
                    <p>let result = calculator.sum(2, 3); // result = 5</p>
                </div>

                <p>В этом примере calculator — это объект, у которого есть метод add. Этот метод принимает два аргумента
                    a и b, складывает их и возвращает результат.</p>
                <p>Этот пример уже почти не используется на практике, но может встречаться в образовательных материалах
                    и устаревшем коде.</p>

                <h2>IIFE (Immediately Invoked Function Expression)</h2>

                <p>Самый экзотический способ объявления функции — IIFE (Immediately Invoked Function Expression). Это
                    функция, которая вызывается сразу после объявления.</p>
                <p>Синтаксис IIFE очень простой. Вы объявляете функцию в круглых скобках и сразу же вызываете ее. Таким
                    образом вы создаёте функцию, которая выполняется только один раз.</p>

                <div class="main__wrapper-box_grey">
                    <p>(function () {</p>
                    <blockquote>// Код, который нужно выполнить сразу после объявления функции
                        })();</blockquote>
                </div>

                <p>IIFE может использоваться для защиты переменных от глобальной области видимости и предотвращения
                    переопределения переменных в других скриптах.</p>
                <p>Допустим, мы объявляем переменную count внутри IIFE. Она будет доступна только внутри функции:</p>

                <div class="main__wrapper-box_grey">
                    <p>(function () {</p>
                    <blockquote>var count = 0;</blockquote>
                    <blockquote>// Используем count внутри IIFE</blockquote>
                    <blockquote>console.log(count);</blockquote>
                    <p>})();</p>
                    <p>// Ошибка: переменная count не определена в глобальной области видимости</p>
                    <p>console.log(count);</p>
                </div>

                <p>IIFE также может использоваться для передачи параметров в другие функции, например:</p>

                <div class="main__wrapper-box_grey">
                    <p>(function (name) {</p>
                    <blockquote>console.log("Привет, " + name);</blockquote>
                    <p>})("R2D2");</p>
                </div>

                <p>Здесь мы передаём имя «R2D2» в IIFE в качестве параметра. И функция выводит на консоль приветствие
                    «Привет, «R2D2».</p>
                <p>IIFE полезна при работе с библиотеками. Например, в ситуации, в которой глобальная область видимости
                    загрязнена. И вы хотите избежать конфликта имён переменных с другими библиотеками или скриптами.</p>
                <p>Это все возможные варианты объявления переменных. Самые часто используемые из них — function
                    declaration, function expression, а также стрелочные и анонимные функции.</p>
                <p>В этом юните мы рассмотрели теоретический аспект этих функций — как они устроены, чем отличаются и
                    где применяются. А в следующем рассмотрим практические применение самых популярных способов.</p>

                <h2><strong>Задание 3.1</strong></h2>

                <p>Создайте функцию-конструктор для объекта Person, которая принимает два параметра: name и age.
                    Конструктор должен установить эти свойства у объекта:</p>
                <p>Пример использования:</p>

                <div class="main__wrapper-box_grey">
                    <p>const person1 = new Person('John', 30);</p>
                    <p>const person2 = new Person('Jane', 25);</p>
                    <p>console.log(person1); // outputs { name: 'John', age: 30 }</p>
                    <p>console.log(person2); // outputs { name: 'Jane', age: 25 }</p>
                </div>
                <blockquote>Посмотреть код</blockquote>
                <div class="main__wrapper-box_grey">
                    <p>function Person(name, age) {</p>
                    <blockquote>this.name = name;</blockquote>
                    <blockquote>this.age = age;</blockquote>
                    <p>}</p>
                </div>
                <hr>

                <h2>Задание 3.2</h2>

                <p>Создайте объект car со свойствами make, model, year и методом getAge, который возвращает количество
                    лет с момента выпуска автомобиля.</p>
                <blockquote>Посмотреть код</blockquote>
                <div class="main__wrapper-box_grey">
                    <p>const car = {</p>
                    <blockquote>make: "Toyota",</blockquote>
                    <blockquote>model: "Camry",</blockquote>
                    <blockquote>year: 2015,</blockquote>
                    <blockquote>getAge: function () {</blockquote>
                    <blockquote>
                        <blockquote>const currentYear = new Date().getFullYear();</blockquote>
                        <blockquote>return currentYear - this.year;</blockquote>
                    </blockquote>
                    <blockquote>}</blockquote>
                    <p>};</p>
                </div>
                <hr>

                <h2>Задание 3.3</h2>

                <p>Создайте объект person со свойствами firstName, lastName и методом getFullName, который возвращает
                    полное имя.</p>
                <blockquote>Посмотреть код</blockquote>
                <div class="main__wrapper-box_grey">
                    <p>const person = {</p>
                    <blockquote>firstName: "John",</blockquote>
                    <blockquote>lastName: "Doe",</blockquote>
                    <blockquote>getFullName: function () {</blockquote>
                    <blockquote>
                        <blockquote>return `${this.firstName} ${this.lastName}`;</blockquote>
                    </blockquote>
                    <blockquote>}</blockquote>
                    <p>};</p>
                </div>
                <hr>

                <h2>Задание 3.4</h2>

                <p>Напишите IIFE функцию, которая выводит в консоль строку "Hello, World!".</p>
                <blockquote>Посмотреть код</blockquote>
                <div class="main__wrapper-box_grey">
                    <p>(function () {</p>
                    <blockquote>console.log("Hello, World!");</blockquote>
                    <p>})();</p>
                </div>
                <hr>

                <h2>Задание 3.5</h2>

                <p>Напишите IIFE функцию, которая принимает число и возвращает его квадрат.</p>
                <blockquote>Посмотреть код</blockquote>
                <div class="main__wrapper-box_grey">
                    <p>(function (num) {</p>
                    <blockquote>return num * num;</blockquote>
                    <p>})(5); // 25</p>
                </div>
                <hr>

                <p><strong>Задание 3.6</strong></p>

                <p>Что выведет в консоль следующий код и почему?</p>

                <div class="main__wrapper-box_grey">
                    <p>console.log(foo);</p>
                    <p>var foo = function () {</p>
                    <blockquote>console.log("Hello, world!");</blockquote>
                    <p>}</p>
                </div>
                <blockquote>undefined</blockquote>
                <hr>

                <h2>Задание 3.7</h2>

                <p>Что выведет в консоль следующий код и почему?</p>

                <div class="main__wrapper-box_grey">
                    <p>bar();</p>
                    <p>var bar = function () {</p>
                    <blockquote>console.log("Hello, world!");</blockquote>
                    <p>}</p>
                </div>
                <blockquote>Ничего, будет ошибка</blockquote>
                <hr>

            </div>
            <!-- кнопки -->
            <div class="main__btn-box">
                <a href="page2.html" class="previous">&laquo; Назад</a>
                <a href="page4.html" class="next">Вперед &raquo;</a>
            </div>
            <div class="main__btn-box-o">
                <a href="page2.html" class="previous round">&#8249;</a>
                <a href="page4.html" class="next round">&#8250;</a>
            </div>
        </div>

        <button onclick="topFunction()" id="myBtn" title="Перейти к началу">вверх</button>

        <script async src="../script/js.js"></script>

        <!-- &lsaquo;&rsaquo;&lsaquo;/&rsaquo;
             &lsaquo;script&rsaquo;&lsaquo;/script&rsaquo; -->
    </div>
</body>

</html>